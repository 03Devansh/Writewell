[
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "12cf15ce-66fe-445a-82ba-f9ec7aa845ef",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC001-User sign-up with valid email and password",
    "description": "Verify that new users can sign up using a valid email and password, and receive a confirmation of successful registration.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Registration Complete! Welcome aboard!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: New user registration did not complete successfully as per the test plan. The user was not confirmed as registered or redirected to the onboarding/dashboard page.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180716123//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.491Z",
    "modified": "2026-01-16T15:26:20.839Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "af231b73-8a65-4759-8903-e36acf7eeeb2",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC002-User sign-up with invalid email format",
    "description": "Ensure the system rejects sign-up attempts with invalid email formats and displays appropriate error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Registration Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The system did not reject the sign-up attempt with an invalid email format as expected. No success message should appear when invalid email is submitted.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_CONTENT_LENGTH_MISMATCH (at http://localhost:5194/node_modules/.vite/deps/lucide-react.js?v=484255dd:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577156475523//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.496Z",
    "modified": "2026-01-16T15:25:56.602Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "f31c0bcc-a05e-4079-8c3f-e15367f6b6b4",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC003-User login with valid credentials",
    "description": "Verify existing users can log in with correct email and password and receive access to the dashboard.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Access Denied: Invalid Credentials').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: User was expected to be authenticated and redirected to dashboard page, but login failed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577179057714//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.502Z",
    "modified": "2026-01-16T15:26:19.218Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "4d59d158-a1aa-4783-a23f-70d5b3f4052b",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC004-User login with incorrect password",
    "description": "Verify system prevents login when the password is incorrect and displays an error message.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Login Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The system did not prevent login with incorrect password as expected. The error message indicating login rejection was not displayed.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577178548622//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.509Z",
    "modified": "2026-01-16T15:26:18.696Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "4cc3d402-5b11-42e2-abd7-adf4af73ad15",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC005-Session persistence after login",
    "description": "Check that user session remains active after page refresh and navigation, providing a seamless experience.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to reload the page to see if login elements appear or check for any alternative navigation or login options.\n        await page.goto('http://localhost:5194/', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the 'Sign in' link to open the login form.\n        frame = context.pages[-1]\n        # Click on the 'Sign in' link to open the login form\n        elem = frame.locator('xpath=html/body/div/div/nav/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click 'Sign in' button to log in.\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Devanshtest9@yopmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test@9')\n        \n\n        frame = context.pages[-1]\n        # Click 'Sign in' button to submit login form\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Retry login by clearing and re-entering credentials, then clicking 'Sign in' again.\n        frame = context.pages[-1]\n        # Clear email input field\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Clear password input field\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('')\n        \n\n        frame = context.pages[-1]\n        # Re-enter email address\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Devanshtest9@yopmail.com')\n        \n\n        frame = context.pages[-1]\n        # Re-enter password\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test@9')\n        \n\n        frame = context.pages[-1]\n        # Click 'Sign in' button to submit login form again\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Refresh the page to check if the user session remains active.\n        await page.goto('http://localhost:5194/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Refresh the page to check if the user session remains active after refresh.\n        await page.goto('http://localhost:5194/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to another page or section to verify if user session remains active after navigation.\n        await page.goto('http://localhost:5194/profile', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Session Expired - Please Log In Again').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test failed: User session did not remain active after page refresh and navigation as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The user session does not remain active after page refresh and navigation. After logging in successfully, refreshing the page or navigating to another page redirects the user back to the login form, indicating the session is not maintained. This results in a non-seamless user experience where the user must log in again after each page load or navigation.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/new-style-guide/planning/design-guidelines.json?import:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/main.tsx?t=1768571846646:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577389999554//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.515Z",
    "modified": "2026-01-16T15:29:50.131Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "77bffa1f-4b81-4b35-840a-4cb462ff6cf1",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC006-User profile editing and saving changes",
    "description": "Verify users can update profile information (name, email, global AI instructions) and changes are saved correctly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Profile update successful!').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The profile updates were not saved or reflected correctly after reload as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180373957//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.522Z",
    "modified": "2026-01-16T15:26:20.520Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "bc3924ae-a6ff-4fa1-ba37-3b803240886b",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC007-Subscription status enforcement for feature access",
    "description": "Validate that subscription status is checked in real-time and restricts access to paid features for non-subscribed users.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Subscription Active').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Subscription status check did not restrict access to paid features for non-subscribed users as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/176857717729304//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.528Z",
    "modified": "2026-01-16T15:26:17.422Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "be3470a5-4459-42ea-83c0-e84d96e4a893",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC008-Subscription trial checkout flow",
    "description": "Test the complete trial subscription checkout process via Polar integration and verify trial subscription is activated.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Trial Subscription Activated Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The trial subscription activation did not complete successfully as expected in the checkout process via Polar integration.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/main.tsx?t=1768571846646:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577179617522//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.534Z",
    "modified": "2026-01-16T15:26:19.772Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "4da6f2cb-c62c-47a4-a8ae-114af92bec78",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC009-Document creation from dashboard",
    "description": "Validate that users can create new documents from the dashboard and the new document opens in the editor.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2026-01-16T15:24:43.540Z",
    "modified": "2026-01-16T15:24:43.540Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "f8287cd9-e482-4c9d-a43b-3ce80f947c00",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC010-Inline document title editing with persistence",
    "description": "Ensure that document titles can be edited inline on the dashboard and changes persist after reload.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Find and click element or link to open the document dashboard\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to navigate to the document dashboard by URL or find alternative navigation options\n        await page.goto('http://localhost:5194/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Input email and password and click sign in\n        frame = context.pages[-1]\n        # Input email\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Devanshtest9@yopmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test@9')\n        \n\n        frame = context.pages[-1]\n        # Click sign in button\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the first document title link to attempt inline editing\n        frame = context.pages[-1]\n        # Click on the first document title link 'Untitled Document' to activate inline editing or open editing mode\n        elem = frame.locator('xpath=html/body/div/div/main/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Document title updated successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The document title could not be edited inline or changes did not persist after dashboard reload as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The document titles cannot be edited inline on the dashboard as clicking the title navigates to an empty document page instead of enabling inline editing. Therefore, the task to ensure inline editing and persistence of document titles cannot be completed.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/components/editor/AIChat.tsx?t=1768571846751:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/new-style-guide/style-guide.css:0:0)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/index.css?t=1768571846646:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577282545977//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.546Z",
    "modified": "2026-01-16T15:28:02.761Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "ce6a4f88-a4ba-48c1-b785-c9a75a51b399",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC011-Document deletion from dashboard",
    "description": "Verify that users can delete documents from the dashboard and the document list updates accordingly.",
    "testStatus": "FAILED",
    "testError": "Test execution timed out after 15 minutes",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "",
    "created": "2026-01-16T15:24:43.552Z",
    "modified": "2026-01-16T15:24:43.552Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "90585bcd-d3ce-4c27-97e6-9f84bcffe793",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC012-Rich text formatting features in editor",
    "description": "Test all rich text formatting options including bold, italic, underline, strikethrough, headings H1-H3, lists, blockquotes, and paragraph formatting.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Rich Text Formatting Successfully Applied').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The test plan execution for verifying all rich text formatting options (bold, italic, underline, strikethrough, headings H1-H3, lists, blockquotes, and paragraph formatting) did not pass as the expected formatted text did not appear correctly in the editor.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577179049643//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.557Z",
    "modified": "2026-01-16T15:26:19.231Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "fb19e03a-3269-4796-b3b0-654df222c4de",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC013-Auto-save completes within 500ms and updates save status indicator",
    "description": "Verify that document changes trigger auto-save which completes within 500ms and the save status indicator updates accordingly.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to scroll down or look for any hidden or off-screen elements that might open or create a document editor\n        await page.mouse.wheel(0, 300)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Auto-save completed successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Auto-save did not complete within 500ms and the save status indicator did not update from 'Saving...' to 'Saved' as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The document editor page is empty with no editor or content area to make changes. Auto-save functionality cannot be tested. Please check the application state or URL.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/new-style-guide/style-guide.css:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/176857719317304//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.563Z",
    "modified": "2026-01-16T15:26:33.320Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "155ce3a7-1b76-438b-939f-18a4b2533fe9",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC014-Manual save shortcut functionality",
    "description": "Ensure that users can manually trigger save using provided shortcuts and the save status indicator reflects saving state.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Manual Save Completed Successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The document was not saved manually using the shortcut, or the save status indicator did not show success as expected.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/main.tsx?t=1768571846646:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577179160852//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.569Z",
    "modified": "2026-01-16T15:26:19.292Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "2a90a513-c48d-4faa-b5b9-c49ed051ae8a",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC015-Unsaved changes warning on navigation",
    "description": "Test that users receive a warning about unsaved changes when trying to navigate away from the editor without saving.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No unsaved changes warning displayed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Expected a warning prompt about unsaved changes when navigating away from the editor without saving, but no such warning was found.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/main.tsx?t=1768571846646:0:0)\n[ERROR] WebSocket connection to 'ws://localhost:5194/?token=0wSvCoaYovzc' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/@vite/client:535:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577178392978//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.575Z",
    "modified": "2026-01-16T15:26:18.553Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "aea3686c-7e64-4cda-a2d1-3d154db1d79d",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC016-Knowledge base add, view, and delete knowledge items",
    "description": "Verify that users can add new knowledge entries, view the list of knowledge items, and delete entries without errors.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Try to find any navigation or menu elements by scrolling or alternative approach to open knowledge base sidebar\n        await page.mouse.wheel(0, 300)\n        \n\n        # -> Try to navigate directly to a knowledge base or editor URL if known or try to open a new tab to search for knowledge base access\n        await page.goto('http://localhost:5194/knowledge-base', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Knowledge Entry Successfully Added').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Unable to verify adding, viewing, or deleting knowledge entries as per the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The knowledge base page is empty with no UI elements to add, view, or delete knowledge items. Therefore, I cannot verify the requested functionality. Please check the application state or user permissions.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/components/editor/KnowledgePanel.tsx:0:0)\n[WARNING] No routes matched location \"/knowledge-base\"  (at http://localhost:5194/node_modules/.vite/deps/react-router-dom.js?v=484255dd:635:48)\n[WARNING] No routes matched location \"/knowledge-base\"  (at http://localhost:5194/node_modules/.vite/deps/react-router-dom.js?v=484255dd:635:48)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577201097901//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.581Z",
    "modified": "2026-01-16T15:26:41.224Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "14c9d4f6-7b5e-4e8f-bba7-801179c2b754",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC017-Knowledge base items included in AI writing context",
    "description": "Ensure that added knowledge base entries are correctly included as context for AI writing assistant responses.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=This knowledge base entry is not included').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test failed: AI responses do not incorporate information from the knowledge base entries as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577181713608//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.587Z",
    "modified": "2026-01-16T15:26:21.854Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "c47a45ff-5919-41c8-8205-17f7725dd1ea",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC018-AI chat assistant response time and accuracy",
    "description": "Verify AI chat assistant responds within 5-10 seconds with relevant answers based on document content, knowledge base, chat history, and AI instructions.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and open the AI chat panel in the editor\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Look for any clickable elements or buttons to open the AI chat panel\n        await page.mouse.wheel(0, -await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Click on 'Sign in' to proceed to login and access the AI chat panel\n        frame = context.pages[-1]\n        # Click on 'Sign in' to proceed to login\n        elem = frame.locator('xpath=html/body/div/div/nav/div/div/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input email and password, then click 'Sign in' button\n        frame = context.pages[-1]\n        # Input email address\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Devanshtest9@yopmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input password\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test@9')\n        \n\n        frame = context.pages[-1]\n        # Click 'Sign in' button\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'New Document' button to open the editor and access the AI chat panel\n        frame = context.pages[-1]\n        # Click on 'New Document' button\n        elem = frame.locator('xpath=html/body/div/div/main/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'New Document' button to open the editor and access the AI chat panel\n        frame = context.pages[-1]\n        # Click on 'New Document' button\n        elem = frame.locator('xpath=html/body/div/div/main/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a context-rich query into the AI chat text area and send it\n        frame = context.pages[-1]\n        # Input a context-rich query into the AI chat text area\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Please help me write an introduction for a document about the benefits of renewable energy.')\n        \n\n        # -> Reload the current document editor page to attempt to restore the AI chat panel and resend the query\n        await page.goto('http://localhost:5194/document/j57b11zpyrhqg4j31f0tw39pc57zan4r', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Click on the first document titled 'Test Document Title' to open the editor and access the AI chat panel\n        frame = context.pages[-1]\n        # Click on 'Test Document Title' document to open the editor\n        elem = frame.locator('xpath=html/body/div/div/main/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Input a context-rich query into the AI chat text area and send it\n        frame = context.pages[-1]\n        # Input a context-rich query into the AI chat text area\n        elem = frame.locator('xpath=html/body/div/div/div/div[3]/div/div[3]/div/textarea').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Please help me write an introduction for a document about the benefits of renewable energy.')\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI chat assistant has failed to respond with relevant answers').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: AI chat assistant did not respond within 5-10 seconds with relevant answers based on document content, knowledge base, chat history, and AI instructions as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The AI chat assistant was tested for response time and relevance by sending a context-rich query about renewable energy benefits. Despite successful login, document creation, and query submission, the assistant did not provide a visible response within 10 seconds on two separate attempts, including after page reload. This indicates a failure to meet the requirement of responding within 5-10 seconds with relevant answers based on document content, knowledge base, chat history, and AI instructions. Task is concluded with this result.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/node_modules/.vite/deps/html2canvas.js?v=484255dd:0:0)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/pages/Dashboard.tsx?t=1768571846646:0:0)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577469779288//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.594Z",
    "modified": "2026-01-16T15:31:09.929Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "8c46be5e-8033-434a-aa3e-8c8b1dc0fc13",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC019-AI chat insertion and copying of responses",
    "description": "Verify users can insert AI-generated responses into the document or copy the text to clipboard successfully.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI response insertion failed').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The AI-generated response was not successfully inserted into the document or copied to clipboard as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577171255508//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.600Z",
    "modified": "2026-01-16T15:26:11.395Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "6f4d44ca-8ae7-4071-bae0-f6e563e8459b",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC020-Global and document-specific AI instructions management",
    "description": "Validate creation, editing, saving, and application of global and document-specific AI instructions to customize AI writing style.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=AI instructions applied successfully').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The AI assistant behavior does not reflect the custom instructions provided as per the test plan. The expected confirmation message 'AI instructions applied successfully' was not found on the page.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577169039013//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.605Z",
    "modified": "2026-01-16T15:26:09.170Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "fc1d496d-6421-4fec-9aa0-e85d183868b2",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC021-Document export to DOCX format preserves formatting",
    "description": "Test exporting document to DOCX format preserves all rich text formatting including styles, headings, lists, and blockquotes accurately.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Export Successful: All formatting preserved').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Exporting document to DOCX did not preserve all rich text formatting including styles, headings, lists, and blockquotes as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180411805//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.611Z",
    "modified": "2026-01-16T15:26:20.527Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "953511f5-8ff6-4900-b32c-bce93572b862",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC022-Document export to PDF preserves formatting and multi-page layout",
    "description": "Verify exporting documents to PDF maintains the styles, headings, and layouts across multiple pages as in the editor.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Export Successful: Document styles and layouts preserved')).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Exported PDF does not preserve content layout and formatting across all pages as required by the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/@react-refresh:0:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180076608//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.618Z",
    "modified": "2026-01-16T15:26:20.216Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "1948cac3-a471-4f5b-a77b-7b68c77f5331",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC023-Responsive UI behavior across desktop, tablet, and mobile devices",
    "description": "Ensure the application UI with three-panel layout adjusts correctly and maintains usability on desktop, tablet, and mobile screen sizes.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Three-panel layout successfully adjusted for desktop, tablet, and mobile views').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: The three-panel layout did not collapse or rearrange appropriately across desktop, tablet, and mobile screen sizes as required by the test plan. UI elements may not be accessible or usable.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180539381//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.624Z",
    "modified": "2026-01-16T15:26:20.677Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "eb6c194d-1041-4932-9cca-8ec8feec7d7e",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC024-Accessibility compliance for keyboard navigation and color contrast",
    "description": "Verify all features support keyboard-only navigation and comply with WCAG AA color contrast standards for accessibility.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Keyboard navigation and WCAG AA color contrast compliance verified').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Keyboard-only navigation and WCAG AA color contrast compliance could not be verified as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577171386942//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.631Z",
    "modified": "2026-01-16T15:26:11.527Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "4ef4c7b1-5a38-417f-ab15-bce4cac22552",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC025-Save operation latency and system uptime",
    "description": "Verify average save operation latency is below 100ms and system maintains 99.9% uptime during extended testing periods.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=System Latency Exceeds Threshold').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Average save operation latency exceeded 100ms or system uptime dropped below 99.9% during extended testing as per the test plan.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577179467965//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.637Z",
    "modified": "2026-01-16T15:26:19.611Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "757ef5e7-9833-4c82-8338-d20b76b558fc",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC026-Robust error handling for network failures during document save",
    "description": "Check the application handles network disruptions gracefully during save operations with retries and error messages.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Network Save Successful').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: The application did not handle network disruptions gracefully during save operations. Expected notification of save error and retry logic was not observed, and document save completion after reconnection did not occur.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577180917487//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.644Z",
    "modified": "2026-01-16T15:26:21.085Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "b3ea8f28-6fd5-47ef-b333-5aadb7be3d25",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC027-Security: password hashing and HTTPS enforcement",
    "description": "Verify passwords are stored using secure hashing and all communications are forced over HTTPS to protect user data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        try:\n            await expect(page.locator('text=Password stored in plain text').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Passwords are not stored securely as hashes or HTTP connections are not properly redirected to HTTPS, compromising user data security.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577168740553//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.650Z",
    "modified": "2026-01-16T15:26:08.936Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "4c11f3af-f5ea-4192-850f-bec75d420ca8",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC028-Security: CSRF protection on state-changing requests",
    "description": "Ensure the application protects against cross-site request forgery (CSRF) attacks on forms and API calls changing user or document data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Locate and inspect any forms or API calls on the page for presence of CSRF tokens.\n        await page.mouse.wheel(0, await page.evaluate('() => window.innerHeight'))\n        \n\n        # -> Try to navigate to a known login or user page by direct URL to find forms for CSRF token inspection.\n        await page.goto('http://localhost:5194/login', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to a registration or user profile page that might contain forms for inspection.\n        await page.goto('http://localhost:5194/register', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Try to navigate to a user dashboard or document editing page that might contain forms or API calls for inspection.\n        await page.goto('http://localhost:5194/dashboard', timeout=10000)\n        await asyncio.sleep(3)\n        \n\n        # -> Inspect the login form for presence of CSRF tokens and submit the form to observe if CSRF tokens are validated.\n        frame = context.pages[-1]\n        # Input the username in the email field\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Devanshtest9@yopmail.com')\n        \n\n        frame = context.pages[-1]\n        # Input the password in the password field\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/div/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test@9')\n        \n\n        frame = context.pages[-1]\n        # Click the Sign in button to submit the login form\n        elem = frame.locator('xpath=html/body/div/div/main/div/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'New Document' button to open the document creation form and inspect for CSRF tokens.\n        frame = context.pages[-1]\n        # Click the 'New Document' button to open the document creation form\n        elem = frame.locator('xpath=html/body/div/div/main/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Trigger a document data change by editing the document title and observe API requests for CSRF tokens.\n        frame = context.pages[-1]\n        # Click to edit the document title\n        elem = frame.locator('xpath=html/body/div/div/header/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on an existing document to open it and inspect for CSRF tokens in forms or API calls during editing.\n        frame = context.pages[-1]\n        # Click on the first document link to open the document for editing\n        elem = frame.locator('xpath=html/body/div/div/main/div[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click to edit the document title to trigger a state-changing API call and observe if CSRF tokens are present in the request.\n        frame = context.pages[-1]\n        # Click to edit the document title\n        elem = frame.locator('xpath=html/body/div/div/header/div/div/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Edit the document title input field to trigger a state-changing API call and monitor the network requests for CSRF tokens.\n        frame = context.pages[-1]\n        # Edit the document title to trigger a state-changing API call\n        elem = frame.locator('xpath=html/body/div/div/header/div/div/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('Test Document Title')\n        \n\n        # -> Make a change in the document content area to trigger another state-changing API call and observe for CSRF tokens in the request.\n        frame = context.pages[-1]\n        # Click the document content area to focus for editing\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/div/div/div[2]/div/div/p').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=CSRF Token Verified Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: CSRF tokens are missing or not validated for all state-changing operations as required by the test plan to protect against CSRF attacks.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "The application does not include CSRF tokens in traditional forms like login and registration, indicating a potential vulnerability to CSRF attacks on these forms. Document creation and editing are handled via API calls, but due to lack of direct network inspection, it is unclear if CSRF tokens are included and validated in these API requests. Further manual or automated network analysis is recommended to confirm CSRF protection on API calls. Overall, the task to ensure CSRF protection is not fully complete due to these limitations.\nBrowser Console Logs:\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/main.tsx?t=1768571846646:0:0)\n[ERROR] Failed to load resource: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/src/App.tsx?t=1768571846646:0:0)\n[WARNING] No routes matched location \"/register\"  (at http://localhost:5194/node_modules/.vite/deps/react-router-dom.js?v=484255dd:635:48)\n[WARNING] No routes matched location \"/register\"  (at http://localhost:5194/node_modules/.vite/deps/react-router-dom.js?v=484255dd:635:48)\n[ERROR] WebSocket connection to 'ws://localhost:5194/?token=0wSvCoaYovzc' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/@vite/client:535:0)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[WARNING] [tiptap warn]: Duplicate extension names found: ['underline']. This can lead to issues. (at http://localhost:5194/node_modules/.vite/deps/chunk-KYWGMG7B.js?v=484255dd:13529:12)\n[ERROR] WebSocket connection to 'wss://necessary-magpie-326.convex.cloud/api/1.31.3/sync' failed: Error in connection establishment: net::ERR_EMPTY_RESPONSE (at http://localhost:5194/node_modules/.vite/deps/convex_react.js?v=484255dd:1223:0)",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577388418473//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.657Z",
    "modified": "2026-01-16T15:29:48.555Z"
  },
  {
    "projectId": "5af314ad-1c8d-4325-823d-55e59b88f4dc",
    "testId": "0c4e918d-b72d-4975-8260-4129a1081636",
    "userId": "34a80478-b0a1-7063-4195-e3dc6eda9424",
    "title": "TC029-User data scoped access control enforcement",
    "description": "Verify that users can only access their own documents, knowledge base items, and profile data and cannot view or modify others' data.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5194\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Access Granted to Other User Data').first).to_be_visible(timeout=30000)\n        except AssertionError:\n            raise AssertionError('Test case failed: Users were able to access documents, knowledge base items, or profile data belonging to other users, violating data protection requirements.')\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Failed to go to the start URL. Err: Error executing action go_to_url: Page.goto: Timeout 60000ms exceeded.\nCall log:\n  - navigating to \"http://localhost:5194/\", waiting until \"load\"\n",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/34a80478-b0a1-7063-4195-e3dc6eda9424/1768577173207229//tmp/test_task/result.webm",
    "created": "2026-01-16T15:24:43.663Z",
    "modified": "2026-01-16T15:26:13.373Z"
  }
]
